#!/usr/bin/perl

use strict;
use warnings;

use Ei;
use Text::Table;
use Clone qw(clone);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

sub usage;
sub fatal;

my $config_file;
GetOptions(
    'c|config-file=s' => \$config_file,
) or usage;
if (!defined $config_file) {
    ($config_file) =
        grep { defined && -f } (
            $ENV{'EI_CONFIG'},
            map { glob($_) } qw(~/.eirc ~/etc/ei/ei.conf /etc/ei/ei.conf)
        )
    ;
}
my $ei = Ei->new(
    defined $config_file ? ('config_file' => $config_file) : (),
);

my %outprop = (
    'default' => [
        ['#'        => 'Item'           ],
        ['title'    => 'Title',    ''   ],
        ['location' => 'Location', ''   ],
    ],
);
my $outform = 'default';
my $display = $ei->{'config'}{'display'};
if ($display) {
    while (my ($form, $disp) = each %$display) {
        my $cols = $disp->{columns} or next;
        my @outprops;
        foreach (@$cols) {
            my ($prop, $label) = @$_{qw(property label)};
            push @outprops, [ $prop, $label, '' ];
        }
        $outprop{$form} = \@outprops;
    }
}

if (@ARGV == 0) {
    @ARGV = ('ls');
}
elsif (@ARGV && $ARGV[0] =~ s{^/(.+)/$}{}) {
    $ARGV[0] = $1;
    unshift @ARGV, 'grep';
}
elsif (@ARGV && $ARGV[0] =~ s{^[+](?=.)}{}) {
    unshift @ARGV, 'add', '-p';
}

&{ __PACKAGE__->can('cmd_' . shift) || usage };

# --- Commands

sub cmd_add {
    usage if @ARGV < 1;
    my $p = shift @ARGV;
    my $proto = $ei->prototype($p) or fatal "No such prototype: $p";
    my $fh;
    my ($n, $nadded, $running) = (0, 0, 1);
    $SIG{INT} = $SIG{QUIT} = $SIG{TERM} = sub { $running = 0; print STDERR "\n" };
ITEM:
    while (1) {
        print STDERR '-' x 80, "\n";
        # printf STDERR "\e[32;1m%80d\e[0m\n", ++$n;
        my $obj = clone($proto->{properties});
        my %placeholders = placeholders($obj);
        my %order = qw(
            id       00000
            uuid     00001
            title    00002
            location 00003
        );
        my @ordered_placeholders = sort {
            my ($ak, $bk) = map { $_->[0] } $a, $b;
            ($order{$ak} // $ak)
            cmp
            ($order{$bk} // $bk)
        } values %placeholders;
        foreach (@ordered_placeholders) {
            my ($key, $valref, $action, @args) = @$_;
            my $sub = __PACKAGE__->can('act_'.$action) || fatal "Unknown placeholder action: $action";
            $sub->($key, $valref, @args);
            last ITEM if !$running;
        }
        if (!defined $fh) {
            my $save_file = $ei->{config}{files}{save};
            $save_file = $ei->{config}{files}{root} . '/' . $save_file if $save_file !~ m{^/};
            open $fh, '>>', scalar glob($save_file) or fatal "Can't save to $save_file: $!";
        }
        last if !$running;
        my $id = $obj->{'id'};
        print STDERR "\e[32mSave $id?\e[0m [Ynq] ";
        my $ans = <STDIN>;
        last if ($ans // 'Q') =~ /^[Qq]/;
        next if $ans =~ /^[Nn]/;
        $ei->write($fh, $obj);
        $nadded++;
    }
    print STDERR '-' x 80, "\n";
    printf STDERR "\n\e[1m%d %s added\e[0m\n",
        $nadded,
        $nadded == 1 ? 'item' : 'items';
}

sub act_mint {
    my ($key, $valref, $m, @etc) = @_;
    my $minter = $ei->{config}{minters}{$m} or fatal "No such minter: $m";
    my ($cmd, $args) = @$minter{qw(command arguments)};
    open my $fh, '-|', $cmd, @{ $args || [] } or die;
    my $val = <$fh>;
    fatal "$cmd: no value returned" if !defined $val;
    chomp $val;
    $$valref = $val;
    my $label = $ei->{config}{labels}{$key} // ucfirst $key;
    print STDERR "  $label: $val\n";
}

sub act_ask {
    my ($key, $valref, @args) = @_;
    my $label = $ei->{config}{labels}{$key} // ucfirst $key;
    print STDERR "  $label: ";
    print STDERR "[$$valref] " if defined $$valref;
    my $val = <STDIN>;
    chomp $val;
    $$valref = $val;
}

sub cmd_ed {
    usage if @ARGV < 1;
    my $id = shift @ARGV;
    my @items = grep { $_->{'#'} eq $id } $ei->items;
    exit 2 if !@items;
    system($ENV{'VISUAL'}||$ENV{'EDITOR'}||'vi', "+$_->{'.'}", $_->{'/'}) for $items[0];
}

sub cmd_ls {
    out( sort byid $ei->items );
}

sub cmd_item {
    usage if @ARGV < 1;
    my $i = shift @ARGV;
    out( grep { $_->{'#'} eq $i } $ei->items );
}

sub cmd_grep {
    usage if @ARGV < 1;
    my $patt = shift @ARGV;
    my $rx = qr/$patt/i;
    out( grep { match(sub { $_ =~ $rx }) } $ei->items );
    #out( grep { 0 < grep { $_ =~ $rx } values %$_ } $ei->items );
}

# --- Other functions

sub instantiate {
    my ($obj) = @_;
}

sub placeholders {
    my ($hash) = @_;
    return _hash_placeholders($hash);
}

sub _hash_placeholders {
    my ($hash, @path) = @_;
    my @p;
    while (my ($k, $v) = each %$hash) {
        my $r = ref $v;
        if ($r eq 'HASH') {
            push @p, _hash_placeholders($v, ".$k");
        }
        elsif ($r eq 'ARRAY') {
            push @p, _array_placeholders($v, "[$k]");
        }
        elsif ($r ne '') {
            die "Huh???";
        }
        elsif ($v =~ /^<(.+)>$/) {
            my $vref = \$hash->{$k};
            my ($action, @args) = split /\s*:\s*/, $1;
            undef $$vref;
            push @p, [ join('', @path, $k), $vref, $action, @args ];
        }
    }
    return map { $_->[0] => $_ } @p;
}

sub byid {
    my ($aa, $an) = ($a->{'#'} =~ /^([a-z]*)([0-9]*)/);
    my ($ba, $bn) = ($b->{'#'} =~ /^([a-z]*)([0-9]*)/);
    return $aa cmp $ba || $an <=> $bn;
}

sub match {
    my ($cond) = @_;
    my %ref2code = (
        '' => sub {
            my ($c) = @_;
            return $c->();
        },
        'HASH' => sub {
            foreach (values %$_) {
                return 1 if match(@_);
            }
        },
        'ARRAY' => sub {
            foreach (@$_) {
                return 1 if match(@_);
            }
        },
    );
    return $ref2code{ref $_}->($cond);
    #return $cond->() if !ref;
    #return match_hash($cond, $_) if $r eq 'HASH';
}

sub out {
    return if !@_;
    my (@fld, @col, @def);
    foreach (@{ $outprop{$outform} }) {
        push @fld, $_->[0];
        push @col, \'  ' if @col;
        push @col, $_->[1];
        push @def, (@$_ > 2 ? $_->[2] : undef);
    }
    my $table = Text::Table->new(@col);
    foreach my $item (@_) {
        my @row;
        foreach my $i (0..$#fld) {
            my ($f, $d) = ($fld[$i], $def[$i]);
            push @row, $item->{$f} // $d // die "No default $f for item $item->{'#'}";
        }
        $table->add(@row);
    }
    print $table->title, $table->rule(sub { '-' x $_[1] }, sub { '' }), $table->body;
    ### printf "%5s %-12.12s %s\n", 'Item', 'Location', 'Description';
    ### foreach (@_) {
    ###     printf "%5d %-12.12s %s\n", $_->{'#'} // 0, $_->{'loc'} // '', $_->{'descrip'} // '';
    ### }
}

sub usage {
    print STDERR "usage: ei [-c CONFIGFILE] COMMAND [OPTION]...\n";
    exit 1;
}

sub fatal {
    print STDERR "ei: @_\n";
    exit 2;
}

